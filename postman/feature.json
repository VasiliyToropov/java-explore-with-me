{
	"info": {
		"_postman_id": "553608b6-cedd-4ad8-9b5f-592023e37420",
		"name": "Feature Tests",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "38627465"
	},
	"item": [
		{
			"name": "Создание нового пользователя",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 201 и данные в формате json\", function () {\r",
							"    pm.response.to.have.status(201);  \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"const source = JSON.parse(pm.request.body.raw);\r",
							"const target = pm.response.json();\r",
							"\r",
							"pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
							"    pm.expect(target.id).to.not.be.null;\r",
							"    pm.expect(target.name).equal(source.name, 'Имя должно соответствовать имени в запросе');\r",
							"    pm.expect(target.email).equal(source.email, 'Почта пользователя должна соответствовать почте пользователя в запросе');\r",
							"});\r",
							"\r",
							"const jsonData = pm.response.json();\r",
							"pm.collectionVariables.set(\"userId\", jsonData.id);"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"email\": \"{{$randomEmail}}\",\r\n    \"name\": \"{{$randomFullName}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://localhost:8080/admin/users",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"admin",
						"users"
					]
				}
			},
			"response": []
		},
		{
			"name": "Создание новой категории",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 201 и данные в формате json\", function () {\r",
							"    pm.response.to.have.status(201);  \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"const source = JSON.parse(pm.request.body.raw);\r",
							"const target = pm.response.json();\r",
							"\r",
							"pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
							"    pm.expect(target.id).to.not.be.null;\r",
							"    pm.expect(target.name).equal(source.name, 'Имя категории должно соответствовать имени категории в запросе');\r",
							"});\r",
							"\r",
							"const jsonData = pm.response.json();\r",
							"pm.collectionVariables.set(\"categoryId\", jsonData.id);"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n  \"name\": \"Подборка {{$randomInt}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://localhost:8080/admin/categories",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"admin",
						"categories"
					]
				}
			},
			"response": []
		},
		{
			"name": "Cоздание нового события",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"// 1. Генерация случайных текстов (с учётом ограничений @Size)\r",
							"const randomText = (min, max) => {\r",
							"    const words = [\"концерт\", \"фестиваль\", \"вебинар\", \"выставка\", \"мастер-класс\", \"спорт\", \"кино\", \"театр\", \"наука\", \"технологии\"];\r",
							"    let result = \"\";\r",
							"    const length = Math.floor(Math.random() * (max - min)) + min;\r",
							"    while (result.length < length) {\r",
							"        result += words[Math.floor(Math.random() * words.length)] + \" \";\r",
							"    }\r",
							"    return result.substring(0, max).trim();\r",
							"};\r",
							"\r",
							"// 2. Дата события: текущее время + 1 день (гарантированно будущая дата)\r",
							"const eventDate = new Date();\r",
							"eventDate.setDate(eventDate.getDate() + 1); // Добавляем 1 день\r",
							"\r",
							"const formattedDate = \r",
							"    eventDate.getFullYear() + \"-\" +\r",
							"    String(eventDate.getMonth() + 1).padStart(2, '0') + \"-\" +\r",
							"    String(eventDate.getDate()).padStart(2, '0') + \" \" +\r",
							"    String(eventDate.getHours()).padStart(2, '0') + \":\" +\r",
							"    String(eventDate.getMinutes()).padStart(2, '0') + \":\" +\r",
							"    String(eventDate.getSeconds()).padStart(2, '0');\r",
							"\r",
							"pm.variables.set(\"formattedEventDate\", formattedDate);\r",
							"\r",
							"// 3. Устанавливаем переменные\r",
							"pm.variables.set(\"dynamicAnnotation\", randomText(20, 2000));\r",
							"pm.variables.set(\"dynamicDescription\", randomText(20, 7000));\r",
							"pm.variables.set(\"dynamicTitle\", randomText(3, 120));\r",
							"pm.variables.set(\"dynamicEventDate\", eventDate);"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 201 и данные в формате json\", function () {\r",
							"    pm.response.to.have.status(201);  \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"const source = JSON.parse(pm.request.body.raw);\r",
							"const target = pm.response.json();\r",
							"\r",
							"pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, description, participantLimit, state, createdOn, location, requestModeration\", function () {\r",
							"pm.expect(target).to.have.property('id');\r",
							"pm.expect(target).to.have.property('title');\r",
							"pm.expect(target).to.have.property('annotation');\r",
							"pm.expect(target).to.have.property('category');\r",
							"pm.expect(target).to.have.property('paid');\r",
							"pm.expect(target).to.have.property('eventDate');\r",
							"pm.expect(target).to.have.property('initiator');\r",
							"pm.expect(target).to.have.property('description');\r",
							"pm.expect(target).to.have.property('participantLimit');\r",
							"pm.expect(target).to.have.property('state');\r",
							"pm.expect(target).to.have.property('createdOn');\r",
							"pm.expect(target).to.have.property('location');\r",
							"pm.expect(target).to.have.property('requestModeration');\r",
							"pm.expect(target).to.have.property('likes');\r",
							"pm.expect(target).to.have.property('dislikes');\r",
							"});\r",
							"\r",
							"pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
							"    pm.expect(target.id).to.not.be.null;\r",
							"    pm.expect(target.title).equal(source.title, 'Название события должно соответствовать названию события в запросе');\r",
							"    pm.expect(target.annotation).equal(source.annotation, 'Аннотация события должна соответствовать аннотации события в запросе');\r",
							"    pm.expect(target.paid.toString()).equal(source.paid.toString(), 'Стоимость события должна соответствовать стоимости события в запросе');\r",
							"    pm.expect(target.eventDate).equal(source.eventDate, 'Дата проведения события должна соответствовать дате проведения события в запросе');\r",
							"    pm.expect(target.description).equal(source.description, 'Описание события должно соответствовать описание события в запросе');\r",
							"    pm.expect(target.participantLimit.toString()).equal(source.participantLimit.toString(), 'Лимит участников события должно соответствовать лимиту участников события в запросе');\r",
							"    pm.expect(target.location.lat.toString()).equal(source.location.lat.toString(), 'Широта локации проведения события должна соответствовать широте локации проведения события в запросе');\r",
							"    pm.expect(target.location.lon.toString()).equal(source.location.lon.toString(), 'Долгота локации проведения события должна соответствовать долготе локации проведения события в запросе');\r",
							"    pm.expect(target.requestModeration.toString()).equal(source.requestModeration.toString(), 'Необходимость модерации события должна соответствовать необходимости модерации события в запросе');\r",
							"});\r",
							"\r",
							"const jsonData = pm.response.json();\r",
							"pm.collectionVariables.set(\"eventId\", jsonData.id);"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n  \"annotation\": \"{{dynamicAnnotation}}\",\r\n  \"category\": \"{{categoryId}}\",  // Динамическая переменная из предыдущего теста\r\n  \"description\": \"{{dynamicDescription}}\",\r\n    \"eventDate\": \"{{formattedEventDate}}\",\r\n  \"location\": {\r\n    \"lat\": 55.751244,\r\n    \"lon\": 37.618423\r\n  },\r\n  \"paid\": false,\r\n  \"participantLimit\": 50,\r\n  \"requestModeration\": true,\r\n  \"title\": \"{{dynamicTitle}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://localhost:8080/users/{{userId}}/events",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"users",
						"{{userId}}",
						"events"
					]
				}
			},
			"response": []
		},
		{
			"name": "Проверка добавления оценки к неопубликованному событию",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 409 - нельзя добавить оценку к неопубликованному событию\", function () {\r",
							"    pm.response.to.have.status(409);  \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"userId\" : {{userId}},\r\n    \"eventId\" : {{eventId}},\r\n    \"ratingType\" : \"LIKE\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://localhost:8080/users/{{userId}}/ratings/{{eventId}}",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"users",
						"{{userId}}",
						"ratings",
						"{{eventId}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Редактирование данных события и его статуса (публикация)",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
							"    pm.response.to.be.ok;    \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"const source = pm.collectionVariables.get('response');\r",
							"const target = pm.response.json();\r",
							"\r",
							"pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, description, participantLimit, state, createdOn, publishedOn, location, requestModeration\", function () {\r",
							"pm.expect(target).to.have.property('id');\r",
							"pm.expect(target).to.have.property('title');\r",
							"pm.expect(target).to.have.property('annotation');\r",
							"pm.expect(target).to.have.property('category');\r",
							"pm.expect(target).to.have.property('paid');\r",
							"pm.expect(target).to.have.property('eventDate');\r",
							"pm.expect(target).to.have.property('initiator');\r",
							"pm.expect(target).to.have.property('description');\r",
							"pm.expect(target).to.have.property('participantLimit');\r",
							"pm.expect(target).to.have.property('state');\r",
							"pm.expect(target).to.have.property('createdOn');\r",
							"pm.expect(target).to.have.property('publishedOn');\r",
							"pm.expect(target).to.have.property('location');\r",
							"pm.expect(target).to.have.property('requestModeration');\r",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "PATCH",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"annotation\" : \"Обновленная аннотация\",\r\n    \"description\" : \"Обновленное описание\",\r\n    \"stateAction\" : \"PUBLISH_EVENT\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://localhost:8080/admin/events/{{eventId}}",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"admin",
						"events",
						"{{eventId}}"
					]
				},
				"description": "Обратите внимание:\n - дата начала события должна быть не ранее чем за час от даты публикации.\n- событие должно быть в состоянии ожидания публикации"
			},
			"response": []
		},
		{
			"name": "Добавление рейтинга к событию",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 201 и данные в формате json\", function () {\r",
							"    pm.response.to.have.status(201);  \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"const target = pm.response.json();\r",
							"\r",
							"pm.test(\"Количество лайков должно соответствовать\", function () {\r",
							"    pm.expect(target.likes).equal(1, 'Количество лайков должно быть равному 1');\r",
							"});\r",
							"\r",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"userId\" : {{userId}},\r\n    \"eventId\" : {{eventId}},\r\n    \"ratingType\" : \"LIKE\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://localhost:8080/users/{{userId}}/ratings/{{eventId}}",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"users",
						"{{userId}}",
						"ratings",
						"{{eventId}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Проверка, что нельзя добавить повторную оценку",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 409 - пользователь не может добавить повторную оценку к событию\", function () {\r",
							"    pm.response.to.have.status(409);  \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"userId\" : {{userId}},\r\n    \"eventId\" : {{eventId}},\r\n    \"ratingType\" : \"DISLIKE\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://localhost:8080/users/{{userId}}/ratings/{{eventId}}",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"users",
						"{{userId}}",
						"ratings",
						"{{eventId}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Cоздание нового события №2",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"// 1. Генерация случайных текстов (с учётом ограничений @Size)\r",
							"const randomText = (min, max) => {\r",
							"    const words = [\"концерт\", \"фестиваль\", \"вебинар\", \"выставка\", \"мастер-класс\", \"спорт\", \"кино\", \"театр\", \"наука\", \"технологии\"];\r",
							"    let result = \"\";\r",
							"    const length = Math.floor(Math.random() * (max - min)) + min;\r",
							"    while (result.length < length) {\r",
							"        result += words[Math.floor(Math.random() * words.length)] + \" \";\r",
							"    }\r",
							"    return result.substring(0, max).trim();\r",
							"};\r",
							"\r",
							"// 2. Дата события: текущее время + 1 день (гарантированно будущая дата)\r",
							"const eventDate = new Date();\r",
							"eventDate.setDate(eventDate.getDate() + 1); // Добавляем 1 день\r",
							"\r",
							"const formattedDate = \r",
							"    eventDate.getFullYear() + \"-\" +\r",
							"    String(eventDate.getMonth() + 1).padStart(2, '0') + \"-\" +\r",
							"    String(eventDate.getDate()).padStart(2, '0') + \" \" +\r",
							"    String(eventDate.getHours()).padStart(2, '0') + \":\" +\r",
							"    String(eventDate.getMinutes()).padStart(2, '0') + \":\" +\r",
							"    String(eventDate.getSeconds()).padStart(2, '0');\r",
							"\r",
							"pm.variables.set(\"formattedEventDate\", formattedDate);\r",
							"\r",
							"// 3. Устанавливаем переменные\r",
							"pm.variables.set(\"dynamicAnnotation\", randomText(20, 2000));\r",
							"pm.variables.set(\"dynamicDescription\", randomText(20, 7000));\r",
							"pm.variables.set(\"dynamicTitle\", randomText(3, 120));\r",
							"pm.variables.set(\"dynamicEventDate\", eventDate);"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 201 и данные в формате json\", function () {\r",
							"    pm.response.to.have.status(201);  \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"const source = JSON.parse(pm.request.body.raw);\r",
							"const target = pm.response.json();\r",
							"\r",
							"pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, description, participantLimit, state, createdOn, location, requestModeration\", function () {\r",
							"pm.expect(target).to.have.property('id');\r",
							"pm.expect(target).to.have.property('title');\r",
							"pm.expect(target).to.have.property('annotation');\r",
							"pm.expect(target).to.have.property('category');\r",
							"pm.expect(target).to.have.property('paid');\r",
							"pm.expect(target).to.have.property('eventDate');\r",
							"pm.expect(target).to.have.property('initiator');\r",
							"pm.expect(target).to.have.property('description');\r",
							"pm.expect(target).to.have.property('participantLimit');\r",
							"pm.expect(target).to.have.property('state');\r",
							"pm.expect(target).to.have.property('createdOn');\r",
							"pm.expect(target).to.have.property('location');\r",
							"pm.expect(target).to.have.property('requestModeration');\r",
							"pm.expect(target).to.have.property('likes');\r",
							"pm.expect(target).to.have.property('dislikes');\r",
							"});\r",
							"\r",
							"pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
							"    pm.expect(target.id).to.not.be.null;\r",
							"    pm.expect(target.title).equal(source.title, 'Название события должно соответствовать названию события в запросе');\r",
							"    pm.expect(target.annotation).equal(source.annotation, 'Аннотация события должна соответствовать аннотации события в запросе');\r",
							"    pm.expect(target.paid.toString()).equal(source.paid.toString(), 'Стоимость события должна соответствовать стоимости события в запросе');\r",
							"    pm.expect(target.eventDate).equal(source.eventDate, 'Дата проведения события должна соответствовать дате проведения события в запросе');\r",
							"    pm.expect(target.description).equal(source.description, 'Описание события должно соответствовать описание события в запросе');\r",
							"    pm.expect(target.participantLimit.toString()).equal(source.participantLimit.toString(), 'Лимит участников события должно соответствовать лимиту участников события в запросе');\r",
							"    pm.expect(target.location.lat.toString()).equal(source.location.lat.toString(), 'Широта локации проведения события должна соответствовать широте локации проведения события в запросе');\r",
							"    pm.expect(target.location.lon.toString()).equal(source.location.lon.toString(), 'Долгота локации проведения события должна соответствовать долготе локации проведения события в запросе');\r",
							"    pm.expect(target.requestModeration.toString()).equal(source.requestModeration.toString(), 'Необходимость модерации события должна соответствовать необходимости модерации события в запросе');\r",
							"});\r",
							"\r",
							"const jsonData = pm.response.json();\r",
							"pm.collectionVariables.set(\"eventId2\", jsonData.id);"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n  \"annotation\": \"{{dynamicAnnotation}}\",\r\n  \"category\": \"{{categoryId}}\",  // Динамическая переменная из предыдущего теста\r\n  \"description\": \"{{dynamicDescription}}\",\r\n    \"eventDate\": \"{{formattedEventDate}}\",\r\n  \"location\": {\r\n    \"lat\": 55.751244,\r\n    \"lon\": 37.618423\r\n  },\r\n  \"paid\": false,\r\n  \"participantLimit\": 50,\r\n  \"requestModeration\": true,\r\n  \"title\": \"{{dynamicTitle}}\"\r\n}\r\n",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://localhost:8080/users/{{userId}}/events",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"users",
						"{{userId}}",
						"events"
					]
				}
			},
			"response": []
		},
		{
			"name": "Создание нового пользователя №2",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 201 и данные в формате json\", function () {\r",
							"    pm.response.to.have.status(201);  \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"const jsonData = pm.response.json();\r",
							"pm.collectionVariables.set(\"userId2\", jsonData.id);"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"email\": \"{{$randomEmail}}\",\r\n    \"name\": \"{{$randomFullName}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://localhost:8080/admin/users",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"admin",
						"users"
					]
				}
			},
			"response": []
		},
		{
			"name": "Редактирование данных события и его статуса (публикация) к событию №2",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
							"    pm.response.to.be.ok;    \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"const source = pm.collectionVariables.get('response');\r",
							"const target = pm.response.json();\r",
							"\r",
							"pm.test(\"Событие должно содержать поля: id, title, annotation, category, paid, eventDate, initiator, description, participantLimit, state, createdOn, publishedOn, location, requestModeration\", function () {\r",
							"pm.expect(target).to.have.property('id');\r",
							"pm.expect(target).to.have.property('title');\r",
							"pm.expect(target).to.have.property('annotation');\r",
							"pm.expect(target).to.have.property('category');\r",
							"pm.expect(target).to.have.property('paid');\r",
							"pm.expect(target).to.have.property('eventDate');\r",
							"pm.expect(target).to.have.property('initiator');\r",
							"pm.expect(target).to.have.property('description');\r",
							"pm.expect(target).to.have.property('participantLimit');\r",
							"pm.expect(target).to.have.property('state');\r",
							"pm.expect(target).to.have.property('createdOn');\r",
							"pm.expect(target).to.have.property('publishedOn');\r",
							"pm.expect(target).to.have.property('location');\r",
							"pm.expect(target).to.have.property('requestModeration');\r",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "PATCH",
				"header": [
					{
						"key": "Accept",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"annotation\" : \"Обновленная аннотация -2\",\r\n    \"description\" : \"Обновленное описание -2\",\r\n    \"stateAction\" : \"PUBLISH_EVENT\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://localhost:8080/admin/events/{{eventId2}}",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"admin",
						"events",
						"{{eventId2}}"
					]
				},
				"description": "Обратите внимание:\n - дата начала события должна быть не ранее чем за час от даты публикации.\n- событие должно быть в состоянии ожидания публикации"
			},
			"response": []
		},
		{
			"name": "Добавление рейтинга к событию№2 от пользователя №1 (дизлайк)",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 201 и данные в формате json\", function () {\r",
							"    pm.response.to.have.status(201);  \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"const target = pm.response.json();\r",
							"\r",
							"pm.test(\"Количество дизлайков должно соответствовать\", function () {\r",
							"    pm.expect(target.dislikes).equal(1, 'Количество лайков должно быть равному 1');\r",
							"});\r",
							"\r",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"userId\" : {{userId}},\r\n    \"eventId\" : {{eventId2}},\r\n    \"ratingType\" : \"DISLIKE\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://localhost:8080/users/{{userId}}/ratings/{{eventId2}}",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"users",
						"{{userId}}",
						"ratings",
						"{{eventId2}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Добавление рейтинга к событию№2 от пользователя №2",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 201 и данные в формате json\", function () {\r",
							"    pm.response.to.have.status(201);  \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"const target = pm.response.json();\r",
							"\r",
							"pm.test(\"Количество лайков должно соответствовать 1\", function () {\r",
							"    pm.expect(target.likes).equal(1, 'Количество лайков должно быть равному 1');\r",
							"});\r",
							"\r",
							"\r",
							"pm.test(\"Количество дизлайков должно соответствовать 1\", function () {\r",
							"    pm.expect(target.dislikes).equal(1, 'Количество лайков должно быть равному 1');\r",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"userId\" : {{userId2}},\r\n    \"eventId\" : {{eventId2}},\r\n    \"ratingType\" : \"LIKE\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "http://localhost:8080/users/{{userId2}}/ratings/{{eventId2}}",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"users",
						"{{userId2}}",
						"ratings",
						"{{eventId2}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Получение событий по лайкам",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
							"    pm.response.to.have.status(200);  \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"const target = pm.response.json();\r",
							"\r",
							"pm.test(\"Должно быть найдено только два события по заданному фильтру\", function () {\r",
							"    pm.expect(target.length).to.eql(2);\r",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "http://localhost:8080/users/{{userId}}/ratings/likes",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"users",
						"{{userId}}",
						"ratings",
						"likes"
					]
				}
			},
			"response": []
		},
		{
			"name": "Получение событий по дизлайкам",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
							"    pm.response.to.have.status(200);  \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"const target = pm.response.json();\r",
							"\r",
							"pm.test(\"Должно быть найдено только два события по заданному фильтру\", function () {\r",
							"    pm.expect(target.length).to.eql(2);\r",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "http://localhost:8080/users/{{userId}}/ratings/likes",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"users",
						"{{userId}}",
						"ratings",
						"likes"
					]
				}
			},
			"response": []
		},
		{
			"name": "Получение списка активных пользователей",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
							"    pm.response.to.have.status(200);  \r",
							"    pm.response.to.be.withBody;\r",
							"    pm.response.to.be.json;\r",
							"});\r",
							"\r",
							"const target = pm.response.json();\r",
							"\r",
							"pm.test(\"Должно быть найдено только два пользователя по заданному фильтру\", function () {\r",
							"    pm.expect(target.length).to.eql(2);\r",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "http://localhost:8080/admin/users/active",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8080",
					"path": [
						"admin",
						"users",
						"active"
					]
				}
			},
			"response": []
		}
	],
	"variable": [
		{
			"key": "userId",
			"value": ""
		},
		{
			"key": "categoryId",
			"value": ""
		},
		{
			"key": "eventId",
			"value": ""
		},
		{
			"key": "eventId2",
			"value": ""
		},
		{
			"key": "userId2",
			"value": ""
		}
	]
}